function [audioOUT, audioIN] = processaudio(audioINfilename, effect, param)
    % Els paràmetres d'entrada són:
    % audioINfilename: string amb el nom del fitxer d'àudio a processar
    % effect: string que indica el tipus d'efecte ('equalizer' o 'reverb')
    % param: vector numèric amb els paràmetres de l'efecte
    
    fs = 44100;  

    [audioIN, originalFs] = audioread(audioINfilename);

    if originalFs ~= fs
        audioIN = resample(audioIN, fs, originalFs);
    end

    load('filtersSOS.mat');
    
    N = 2048; 
    x = [1; zeros(N-1, 1)];    

    h_LP = sosfilt(SOS_LP, x);
    h_BP = sosfilt(SOS_BP, x);
    h_HP = sosfilt(SOS_HP, x);
    
    [H_LP, f] = freqz(h_LP, 1, N, fs);
    [H_BP, f] = freqz(h_BP, 1, N, fs);
    [H_HP, f] = freqz(h_HP, 1, N, fs);

    switch effect
        case 'equalizer'
            linearGains = 10.^(param / 20);  

            SOS_LP(1, 1:3) = SOS_LP(1, 1:3) * linearGains(1);
            SOS_BP(1, 1:3) = SOS_BP(1, 1:3) * linearGains(2);
            SOS_HP(1, 1:3) = SOS_HP(1, 1:3) * linearGains(3);

            audioOUT_LP = sosfilt(SOS_LP, audioIN);
            audioOUT_BP = sosfilt(SOS_BP, audioIN);
            audioOUT_HP = sosfilt(SOS_HP, audioIN);

            audioOUT = audioOUT_LP + audioOUT_BP + audioOUT_HP;
          
            H_combined = H_LP .* linearGains(1) + H_BP .* linearGains(2) + H_HP .* linearGains(3);
            phase_combined = unwrap(angle(H_combined)); % Unwrap the phase for better visualization
            
            audioIN_fft = fft(audioIN, N);
            audioOUT_fft = fft(audioOUT, N);
            f_audio = fs*(0:(N/2))/N;
            
            figure;
            subplot(3, 1, 1);
            semilogx(fs, 20*log10(abs(H_LP)), 'b'); 
            hold on;
            semilogx(fs, 20*log10(abs(H_BP)), 'r'); 
            semilogx(fs, 20*log10(abs(H_HP)), 'y');
            hold off;
            title('Individual Filters Magnitude Response');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');
            legend('Low Pass', 'Band Pass', 'High Pass');
            grid on;
            
            % Subplot for Custom Filter Response
            subplot(3, 1, 2);
            semilogx(fs, 20*log10(abs(H_combined)));
            title('Custom Filter Magnitude Response');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');
            grid on;
            
            % Subplot for Custom Filter Phase
            subplot(3, 1, 3);   
            semilogx(fs, phase_combined * 180 / pi);
            title('Custom Filter Phase');
            xlabel('Frequency (Hz)');
            ylabel('Phase (degrees)');
            grid on;
            
            figure;
            
            subplot(2,2, 1)
            f_audio = linspace(0, fs/2, N/2+1); % Correct frequency vector
            plot(f_audio, 20*log10(abs(audioIN_fft(1:N/2+1))));
            title('Original Audio Frequency Spectrum');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');
            
            subplot(2,2, 2)
            plot((1:length(audioIN))/fs, audioIN);
            title('Original Audio Signal');
            xlabel('Time (s)');
            ylabel('Amplitude');
            
            subplot(2,2, 3)
            plot(f_audio, 20*log10(abs(audioOUT_fft(1:N/2+1))));
            title('Filtered Audio Frequency Spectrum');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');

            subplot(2,2, 4)
            plot((1:length(audioOUT))/fs, audioOUT);
            title('Filtered Audio Signal');
            xlabel('Time (s)');
            ylabel('Amplitude');

            % Adjust the layout to prevent subplot overlapping
            sgtitle('Equalizer Effect Applied');
            set(gcf, 'Position', get(0, 'Screensize')); % Optional: Maximize figure to fit screen

           
        case 'reverb'
            Tr = param(1);  % Reverberation time in seconds
            M = param(2);   % Mix coefficient in percent
        
            c = -log(0.001) / (Tr * fs);
        
            noiseLength = Tr * fs;
            noise = randn(noiseLength, 1);
        
            t = (0:noiseLength-1)'/fs;
            envelope = exp(-c * t);
            h_reverb = envelope .* noise;
        
            h_reverb = h_reverb / norm(h_reverb);
        
            % Apply the reverberation effect
            paddedAudioIN = [audioIN; zeros(length(h_reverb)-1, 1)];
            audioOUT_reverb = fftfilt(h_reverb, paddedAudioIN);
        
            audioOUT = audioIN * (1 - M/100) + audioOUT_reverb(1:length(audioIN)) * (M/100);

            % Assuming audioOUT is the audio signal after applying reverberation
            
            % Compute FFT for the original and filtered signals
            audioIN_fft = fft(audioIN);
            audioOUT_fft = fft(audioOUT);
            f_audio = fs*(0:(length(audioIN)/2))/length(audioIN);
            
            % Plot 1: Original Frequency Spectrum
            figure;
            plot(f_audio, audioIN_fft(1:length(audioIN)/2+1));
            title('Original Audio Frequency Spectrum');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');
            
            % Plot 2: Original Time-Domain Signal
            figure;
            plot((1:length(audioIN))/fs, audioIN);
            title('Original Audio Signal');
            xlabel('Time (s)');
            ylabel('Amplitude');
            
            % Plot 3: Filtered Frequency Spectrum
            figure;
            plot(f_audio, audioOUT_fft(1:length(audioOUT)/2+1));
            title('Reverberated Audio Frequency Spectrum');
            xlabel('Frequency (Hz)');
            ylabel('Magnitude (dB)');
            
            % Plot 4: Filtered Time-Domain Signal
            figure;
            plot((1:length(audioOUT))/fs, audioOUT);
            title('Reverberated Audio Signal');
            xlabel('Time (s)');
            ylabel('Amplitude');

        case 'none'
            soundsc(audioIN, fs);

        otherwise
            error('Tipus d''efecte no vàlid. Trieu ''equalizer'' o ''reverb''.');
    end

    % Reproduir l'àudio de sortida
    soundsc(audioOUT, fs);

end
